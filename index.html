<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Group Expense Tracker — Real-time</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind config (dark theme colors)
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            surface: 'rgba(30,30,30,1)',
            bg: '#0b0f13',
            primary: '#7c3aed',
            accent: '#06b6d4',
            danger: '#ef4444',
            success: '#10b981',
            muted: '#94a3b8'
          }
        }
      }
    }
  </script>

  <style>
    :root{
      --bg-color: #0b0f13;
      --surface-color: #0e1216;
      --primary-color: #7c3aed;
      --accent-color: #06b6d4;
    }
    body { background: linear-gradient(180deg,var(--bg-color), #081019); }
    /* subtle chat scrollbar */
    .scrollbar-thin::-webkit-scrollbar { height:8px; width:8px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.06); border-radius:8px; }
  </style>
</head>
<body class="dark text-slate-200 antialiased min-h-screen">

<!-- Main App Container -->
<div id="app" class="min-h-screen flex flex-col md:flex-row">

  <!-- LEFT: Sidebar (Balances + Admin) -->
  <aside class="w-full md:w-80 bg-surface p-4 md:h-screen md:sticky top-0 border-r border-slate-800">
    <div class="flex items-center gap-3 mb-4">
      <div class="w-12 h-12 rounded-lg bg-gradient-to-br from-primary to-accent flex items-center justify-center text-white font-bold text-lg">AE</div>
      <div>
        <div class="text-lg font-semibold">AI Expense</div>
        <div class="text-sm text-slate-400">Real-time Group Tracker</div>
      </div>
    </div>

    <div id="authArea" class="space-y-3">
      <!-- Dynamic auth UI injected by JS -->
    </div>

    <hr class="border-slate-800 my-4" />

    <div>
      <h3 class="text-sm uppercase text-slate-400 mb-2">Current Balances</h3>
      <div id="balancesList" class="space-y-2 max-h-72 overflow-y-auto scrollbar-thin"></div>

      <div class="mt-3">
        <button id="exportCSV" class="w-full py-2 rounded-md bg-slate-700 hover:bg-slate-650 disabled:opacity-40" title="Export processed transactions to CSV">
          Export Processed CSV
        </button>
      </div>
    </div>

    <div id="adminPanel" class="mt-6 hidden">
      <hr class="border-slate-800 my-4" />
      <h3 class="text-sm uppercase text-slate-400 mb-2">Admin: Pending Users</h3>
      <div id="pendingUsers" class="space-y-2 max-h-48 overflow-y-auto scrollbar-thin"></div>
    </div>

    <div class="mt-6 text-xs text-slate-500">
      <div>Built with Firebase + OpenAI (Gemini style) parsing.</div>
      <div class="mt-2">⚠️ Replace API keys & Firebase config before use. Don't publish keys client-side.</div>
    </div>
  </aside>

  <!-- RIGHT: Main Panel (Chat-style transactions + Input) -->
  <main class="flex-1 p-4 md:p-8 flex flex-col min-h-screen">
    <div class="flex-1 flex flex-col bg-transparent">
      <!-- Chat / Transaction History -->
      <div id="chatArea" class="flex-1 overflow-auto p-4 rounded-xl border border-slate-800 bg-gradient-to-b from-transparent to-[#071018] scrollbar-thin">
        <!-- messages injected here -->
      </div>

      <!-- Input area -->
      <div class="mt-4">
        <div id="userInfo" class="flex items-center justify-between text-sm text-slate-400 mb-2">
          <!-- user name/role -->
        </div>

        <div class="flex gap-3">
          <textarea id="nlInput" rows="2" placeholder="E.g., 'paid 2000 for petrol, split with all' or 'I paid 150 for dinner with Bob and Charlie'" class="flex-1 resize-none rounded-xl bg-slate-900 border border-slate-800 p-3 focus:outline-none" ></textarea>
          <div class="flex flex-col gap-2">
            <button id="sendBtn" class="px-4 py-2 rounded-xl bg-primary text-white hover:brightness-95 disabled:opacity-50">Send</button>
            <button id="quickSplitBtn" class="px-4 py-2 rounded-xl bg-slate-700 text-slate-200 text-xs hover:bg-slate-600">Quick Split</button>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- Modal for Pending Block -->
<div id="pendingModal" class="fixed inset-0 bg-black/70 hidden items-center justify-center z-50">
  <div class="bg-surface p-6 rounded-lg w-11/12 max-w-md text-center">
    <h3 class="text-xl font-semibold mb-2">Access Pending</h3>
    <p class="text-slate-400 mb-4">Your account is pending approval by an admin. You cannot use the app until an admin approves you.</p>
    <div class="flex justify-center gap-2">
      <button id="signOutPending" class="px-4 py-2 rounded bg-red-600">Sign out</button>
    </div>
  </div>
</div>

<!-- Modal for Debt Details -->
<div id="debtModal" class="fixed inset-0 bg-black/60 hidden items-center justify-center z-50">
  <div class="bg-surface p-5 rounded-lg w-11/12 max-w-lg">
    <div class="flex justify-between items-center mb-4">
      <h3 id="debtModalTitle" class="text-lg font-semibold">Debt details</h3>
      <button id="closeDebtModal" class="text-slate-400 hover:text-white">✕</button>
    </div>
    <div id="debtModalBody" class="space-y-2 text-sm text-slate-300">
      <!-- details -->
    </div>
  </div>
</div>

<!-- Firebase SDKs (modular compat) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
/* ================================
   CONFIG: Fill these before running
   ================================ */
const FIREBASE_CONFIG = {
  apiKey: "YOUR_FIREBASE_API_KEY",
  authDomain: "YOUR_FIREBASE_AUTH_DOMAIN",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_BUCKET",
  messagingSenderId: "YOUR_MSG_SENDER_ID",
  appId: "YOUR_APP_ID"
};

// For OpenAI/Gemini style requests. For production, route via server.
const OPENAI_API_KEY = "YOUR_OPENAI_API_KEY";  // *** Replace *** (don't expose in production)

/* ================================
   Initialize Firebase
   ================================ */
firebase.initializeApp(FIREBASE_CONFIG);
const auth = firebase.auth();
const db = firebase.firestore();

db.settings({ignoreUndefinedProperties: true});

/* ================================
   Global State + Helpers
   ================================ */
let currentUser = null;
let usersMap = {};        // uid -> {email, name, role, status}
let groupMembers = [];    // array of approved member objects {uid,email,name}
let transactions = [];    // real-time transactions list

// Collections
const usersCol = db.collection('users');
const membersCol = db.collection('group_members');
const txCol = db.collection('transactions');

/* ================================
   Auth UI & Flows
   ================================ */
const authArea = document.getElementById('authArea');
const chatArea = document.getElementById('chatArea');
const balancesList = document.getElementById('balancesList');
const pendingModal = document.getElementById('pendingModal');
const adminPanel = document.getElementById('adminPanel');
const pendingUsersDiv = document.getElementById('pendingUsers');
const userInfo = document.getElementById('userInfo');
const sendBtn = document.getElementById('sendBtn');
const nlInput = document.getElementById('nlInput');
const exportCSV = document.getElementById('exportCSV');

function renderAuthUI() {
  authArea.innerHTML = '';
  const user = auth.currentUser;
  if (!user) {
    // Sign up / Sign in form
    authArea.innerHTML = `
      <div class="space-y-2">
        <input id="email" type="email" placeholder="Email" class="w-full px-3 py-2 rounded bg-slate-900 border border-slate-800" />
        <input id="password" type="password" placeholder="Password" class="w-full px-3 py-2 rounded bg-slate-900 border border-slate-800" />
        <div class="flex gap-2">
          <button id="signUpBtn" class="flex-1 py-2 rounded bg-primary text-white">Sign up</button>
          <button id="signInBtn" class="flex-1 py-2 rounded bg-slate-700">Sign in</button>
        </div>
        <div class="text-xs text-slate-400">Tip: admin account is <b>admin@expense.com</b> (it will auto-approve).</div>
      </div>`;
    document.getElementById('signUpBtn').onclick = async () => {
      const email = document.getElementById('email').value.trim();
      const pwd = document.getElementById('password').value;
      if (!email || !pwd) return alert('Enter email & password');
      try {
        const cred = await auth.createUserWithEmailAndPassword(email, pwd);
        const u = cred.user;
        // create user doc: role & status
        const role = (email.toLowerCase() === 'admin@expense.com') ? 'admin' : 'member';
        const status = (email.toLowerCase() === 'admin@expense.com') ? 'approved' : 'pending';
        await usersCol.doc(u.uid).set({
          email, name: email.split('@')[0], role, status, createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        if (status === 'approved') {
          // add to group_members for admin
          await membersCol.doc(u.uid).set({uid: u.uid, email, name: email.split('@')[0], joinedAt: firebase.firestore.FieldValue.serverTimestamp()});
        }
        alert('Account created. If pending, please wait for admin approval.');
        renderAuthUI();
      } catch (err) {
        console.error(err);
        alert(err.message || err);
      }
    };
    document.getElementById('signInBtn').onclick = async () => {
      const email = document.getElementById('email').value.trim();
      const pwd = document.getElementById('password').value;
      if (!email || !pwd) return alert('Enter email & password');
      try {
        await auth.signInWithEmailAndPassword(email, pwd);
        renderAuthUI();
      } catch (err) {
        console.error(err);
        alert(err.message || err);
      }
    };
  } else {
    // show signed in
    authArea.innerHTML = `
      <div class="p-3 bg-slate-900 rounded-lg">
        <div class="font-semibold">${currentUser?.name || currentUser?.email}</div>
        <div class="text-xs text-slate-400">${currentUser?.email}</div>
        <div class="mt-3 text-xs text-slate-400">Role: <span id="meRole">${currentUser?.role || 'member'}</span></div>
        <div class="mt-3 flex gap-2">
          <button id="signOut" class="flex-1 py-2 rounded bg-red-600">Sign out</button>
        </div>
      </div>`;
    document.getElementById('signOut').onclick = () => auth.signOut();
  }
}

/* ================================
   Realtime listeners
   ================================ */

// Listen for all user docs
usersCol.onSnapshot(snap => {
  snap.docChanges().forEach(change => {
    const d = change.doc.data();
    usersMap[change.doc.id] = {...d, uid: change.doc.id};
  });
  // refresh UI where needed
  renderPendingUsers();
  if (currentUser) renderAuthUI();
});

// group members (approved)
membersCol.onSnapshot(snap => {
  groupMembers = [];
  snap.forEach(doc => groupMembers.push({uid: doc.id, ...doc.data()}));
  renderBalances(); // recalc
});

// transactions (listen live)
txCol.orderBy('createdAt','desc').limit(500).onSnapshot(snap => {
  transactions = [];
  snap.forEach(doc => transactions.push({id: doc.id, ...doc.data()}));
  renderTransactions();
  renderBalances();
});

/* ================================
   Admin: Pending Users
   ================================ */
function renderPendingUsers(){
  const pending = Object.values(usersMap).filter(u => u.status === 'pending');
  pendingUsersDiv.innerHTML = '';
  if (pending.length === 0) pendingUsersDiv.innerHTML = `<div class="text-xs text-slate-400">No pending users</div>`;
  pending.forEach(u => {
    const el = document.createElement('div');
    el.className = 'flex items-center justify-between p-2 rounded bg-slate-900 border border-slate-800';
    el.innerHTML = `
      <div>
        <div class="font-medium">${u.name || u.email}</div>
        <div class="text-xs text-slate-400">${u.email}</div>
      </div>
      <div class="flex gap-2">
        <button class="px-3 py-1 rounded bg-green-600 approveBtn">Approve</button>
        <button class="px-3 py-1 rounded bg-red-600 rejectBtn">Reject</button>
      </div>
    `;
    pendingUsersDiv.appendChild(el);
    el.querySelector('.approveBtn').onclick = async () => {
      try {
        await usersCol.doc(u.uid).update({status: 'approved'});
        // add to group_members
        await membersCol.doc(u.uid).set({uid: u.uid, email: u.email, name: u.name || u.email.split('@')[0], joinedAt: firebase.firestore.FieldValue.serverTimestamp()});
        alert('User approved.');
      } catch (e) { console.error(e); alert('Error'); }
    };
    el.querySelector('.rejectBtn').onclick = async () => {
      try {
        await usersCol.doc(u.uid).update({status: 'rejected'});
        alert('User rejected.');
      } catch (e) { console.error(e); alert('Error'); }
    };
  });
}

/* ================================
   Render Transactions (chat history)
   ================================ */
function renderTransactions(){
  chatArea.innerHTML = '';
  // Show in chronological (oldest first) by reversing transactions array before rendering
  const ordered = [...transactions].reverse();
  ordered.forEach(tx => {
    // original user message
    const userEl = document.createElement('div');
    userEl.className = 'mb-3';
    userEl.innerHTML = `
      <div class="text-xs text-slate-400 mb-1">${tx.fromName || tx.fromEmail || 'Anonymous'} • ${tx.createdAt ? new Date(tx.createdAt.seconds*1000).toLocaleString() : ''}</div>
      <div class="inline-block px-4 py-2 rounded-lg bg-slate-800 text-slate-100">${tx.rawText}</div>
    `;
    chatArea.appendChild(userEl);

    // processed card if exists
    if (tx.status === 'processed') {
      const p = document.createElement('div');
      p.className = 'mb-6 mt-2 p-3 rounded-lg border border-slate-800 bg-gradient-to-br from-slate-900 to-slate-950';
      p.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 rounded-full bg-green-600 flex items-center justify-center text-white text-sm">✓</div>
            <div>
              <div class="font-semibold">${tx.parsed?.description || 'Expense'}</div>
              <div class="text-xs text-slate-400">Payer: ${tx.parsed?.payer || 'Unknown'} • Amount: ${formatMoney(tx.parsed?.total_amount)}</div>
            </div>
          </div>
        </div>
        <div class="text-xs text-slate-300">
          <b>Split:</b>
          <div class="mt-2 space-y-1">
            ${ (tx.parsed?.split_recipients || []).map(s => `<div class="flex justify-between"><div>${s.name}</div><div class="font-semibold">${formatMoney(s.owed)}</div></div>`).join('') }
          </div>
        </div>
      `;
      chatArea.appendChild(p);
    } else if (tx.status === 'error') {
      const e = document.createElement('div');
      e.className = 'mb-6 mt-2 p-3 rounded-lg border border-rose-700 bg-[#2b0f10]';
      e.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 rounded-full bg-rose-600 flex items-center justify-center text-white text-sm">✕</div>
          <div>
            <div class="font-semibold">Parsing Error</div>
            <div class="text-xs text-slate-400">${tx.errorMessage || 'Could not parse the input.'}</div>
          </div>
        </div>
      `;
      chatArea.appendChild(e);
    } else {
      // pending
      const p = document.createElement('div');
      p.className = 'mb-6 mt-2 p-3 rounded-lg border border-slate-700 bg-slate-900 text-slate-400';
      p.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 rounded-full bg-yellow-500 flex items-center justify-center text-black text-sm">…</div>
          <div>
            <div class="font-semibold">Processing</div>
            <div class="text-xs text-slate-400">AI parsing in progress...</div>
          </div>
        </div>
      `;
      chatArea.appendChild(p);
    }
  });

  // Scroll to bottom
  chatArea.scrollTop = chatArea.scrollHeight;
}

/* ================================
   Utilities
   ================================ */
function formatMoney(v){
  if (v == null) return '--';
  const n = Number(v);
  if (isNaN(n)) return v;
  return '$' + n.toFixed(2);
}

/* ================================
   Send / Parse Input (AI integration)
   ================================ */

async function createTransactionRaw(rawText){
  if (!auth.currentUser) return alert('Sign in first.');
  // Save an initial transaction doc with status 'pending'
  const docRef = await txCol.add({
    fromUid: auth.currentUser.uid,
    fromEmail: auth.currentUser.email,
    fromName: currentUser?.name || auth.currentUser.email,
    rawText,
    status: 'pending',
    createdAt: firebase.firestore.FieldValue.serverTimestamp()
  });
  return docRef.id;
}

// AI parse using OpenAI Responses endpoint (Gemini-style JSON forcing).
// NOTE: For production deploy server-side to hide key. This function sends client-side.
async function parseWithAI(rawText, txId) {
  // Craft system + user prompt instructing JSON only output
  const prompt = `
You are an assistant who MUST parse a user's expense sentence into strict JSON only.
Return exactly one JSON object with the following fields:
{
  "payer": "<payer name or email>", 
  "total_amount": <number>, 
  "description": "<short description>", 
  "split_recipients": [
     {"name":"<recipient name>", "owed": <number>}, ...
  ]
}
Rules:
- If 'split' words like "split with all" or "split for all" appear, split equally among all approved group members (including payer).
- If recipients aren't named, default to 'all' meaning everyone in group_members.
- Output numeric values (floats allowed) for amounts.
- If you cannot parse, return a JSON with {"error": "<explain why>"}.
Make the JSON compact and nothing else. Input: "${rawText.replaceAll('"','\\"')}"
  `.trim();

  try {
    // Using OpenAI 'responses' endpoint
    const res = await fetch('/api/parse', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({ input: prompt })
});

    if (!res.ok) {
      const t = await res.text();
      throw new Error('AI request failed: ' + t);
    }
    const data = await res.json();

    // OpenAI responses API returns structure; try extract text
    let aiText = '';
    if (data.output && Array.isArray(data.output) && data.output.length) {
      // new Responses API might have content array
      const out = data.output.find(o => o.type === 'message') || data.output[0];
      if (out && out.content) {
        if (typeof out.content === 'string') aiText = out.content;
        else if (Array.isArray(out.content)) {
          aiText = out.content.map(c => (c.text || '')).join('');
        } else if (out.content[0] && out.content[0].text) aiText = out.content[0].text;
      } else if (data.output_text) {
        aiText = data.output_text;
      }
    } else if (data.choices && data.choices[0] && data.choices[0].message) {
      aiText = data.choices[0].message.content;
    } else if (data.output_text) {
      aiText = data.output_text;
    } else {
      aiText = JSON.stringify(data);
    }

    // Trim and try parse JSON inside the aiText
    const jsonStr = extractJSON(aiText);
    if (!jsonStr) {
      // Save error
      await txCol.doc(txId).update({status: 'error', errorMessage: 'AI did not return JSON.', rawAI: aiText});
      return {ok:false, error: 'AI did not return JSON.'};
    }
    const parsed = JSON.parse(jsonStr);

    if (parsed.error) {
      await txCol.doc(txId).update({status:'error', errorMessage: parsed.error, rawAI: aiText});
      return {ok:false, error: parsed.error};
    }

    // If split recipients are "all" or empty - expand from groupMembers
    let splitRecipients = parsed.split_recipients || [];
    if (Array.isArray(splitRecipients) && splitRecipients.length === 1 && (splitRecipients[0].name || '').toLowerCase() === 'all') {
      splitRecipients = groupMembers.map(m => ({name: m.name || m.email, uid: m.uid}));
    }
    if (!splitRecipients || splitRecipients.length === 0) {
      // if not specified, default to payer only (payer pays all)
      splitRecipients = [{name: parsed.payer || 'Unknown'}];
    }

    // If split_recipients don't include amounts, split equally
    const amt = Number(parsed.total_amount) || 0;
    let recipientsWithAmounts;
    if (splitRecipients.every(r => typeof r.owed === 'number')) {
      recipientsWithAmounts = splitRecipients;
    } else {
      const equal = +(amt / splitRecipients.length).toFixed(2);
      // adjust rounding to ensure sum equals total
      recipientsWithAmounts = splitRecipients.map((r, idx) => ({name: r.name || r, owed: equal}));
      const sum = recipientsWithAmounts.reduce((s,r)=>s + (Number(r.owed)||0),0);
      const diff = +(amt - sum).toFixed(2);
      if (Math.abs(diff) >= 0.01) {
        // adjust first recipient
        recipientsWithAmounts[0].owed = +(recipientsWithAmounts[0].owed + diff).toFixed(2);
      }
    }

    // Attach uids by matching names/emails loosely to groupMembers
    recipientsWithAmounts = recipientsWithAmounts.map(r => {
      const match = groupMembers.find(m => (m.email && m.email.toLowerCase() === (r.name||'').toLowerCase()) || (m.name && m.name.toLowerCase() === (r.name||'').toLowerCase()));
      return {...r, uid: match ? match.uid : undefined};
    });

    // Update transaction doc to processed
    await txCol.doc(txId).update({
      status: 'processed',
      parsed: {
        payer: parsed.payer,
        total_amount: Number(parsed.total_amount),
        description: parsed.description || parsed.desc || '',
        split_recipients: recipientsWithAmounts
      },
      rawAI: aiText,
      processedAt: firebase.firestore.FieldValue.serverTimestamp()
    });

    return {ok:true};

  } catch (err) {
    console.error('parse error', err);
    await txCol.doc(txId).update({status: 'error', errorMessage: (err.message || String(err))});
    return {ok:false, error: err.message || String(err)};
  }
}

// Helper: extract JSON object from text (first {...})
function extractJSON(text){
  if (!text) return null;
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start === -1 || end === -1 || end < start) return null;
  const sub = text.substring(start, end+1);
  try { JSON.parse(sub); return sub; } catch (e) { return null; }
}

/* ================================
   Debt Simplification Algorithm
   ================================ */
/*
  Approach:
  - For all processed transactions, compute net balance per member (positive = they are owed money).
  - For each transaction: payer paid total_amount; each recipient owes their share.
  - net[payer] += total_amount - sum(owed_by_payer_if_included); net[recipient] -= owed
  - Then simplify: repeatedly match max creditor and max debtor to settle amounts.
*/

function computeNetBalances(){
  const balance = {}; // uid/name -> number (positive = owed to them)
  // init with all group members
  groupMembers.forEach(m => balance[m.uid] = 0);

  // loop processed transactions
  transactions.filter(t => t.status === 'processed').forEach(t => {
    const payerName = t.parsed.payer;
    // try match payer uid
    let payerUid = groupMembers.find(m => (m.email && m.email.toLowerCase() === (payerName||'').toLowerCase()) || (m.name && m.name.toLowerCase() === (payerName||'').toLowerCase()))?.uid;
    if (!payerUid) {
      // if fromUid exists, prefer that
      payerUid = t.fromUid || null;
    }
    const payerKey = payerUid || ('payer:'+payerName);
    if (!(payerKey in balance)) balance[payerKey] = 0;

    const total = Number(t.parsed.total_amount) || 0;
    // Add to payer account
    balance[payerKey] += total;

    // subtract recipients
    (t.parsed.split_recipients || []).forEach(r => {
      const uid = r.uid || ('recipient:'+r.name);
      if (!(uid in balance)) balance[uid] = 0;
      balance[uid] -= Number(r.owed) || 0;
    });
  });

  // Map keys back to human names
  const entries = Object.entries(balance).map(([k,v]) => {
    const member = groupMembers.find(m=>m.uid===k);
    return {key:k, name: member ? member.name : (k.startsWith('payer:') || k.startsWith('recipient:') ? k.split(':')[1] : (usersMap[k]?.name || usersMap[k]?.email || k)), uid: member ? member.uid : k, balance: +v};
  });

  return entries;
}

// Simplify debts -> returns array of payments {fromUid, toUid, amount, fromName, toName}
function simplifyDebts(balances){
  // make arrays of creditors and debtors
  const creditors = balances.filter(b => b.balance > 0).map(b => ({...b}));
  const debtors = balances.filter(b => b.balance < 0).map(b => ({...b, balance: -b.balance}));

  const payments = [];
  // sort descending creditors by balance, debtors by balance
  creditors.sort((a,b)=>b.balance-a.balance);
  debtors.sort((a,b)=>b.balance-a.balance);

  let i = 0, j = 0;
  while (i < creditors.length && j < debtors.length) {
    const cred = creditors[i];
    const debt = debtors[j];
    const settle = Math.min(cred.balance, debt.balance);
    if (settle <= 0.001) break;
    payments.push({
      fromUid: debt.uid, toUid: cred.uid,
      amount: +settle.toFixed(2),
      fromName: debt.name, toName: cred.name
    });
    cred.balance = +(cred.balance - settle).toFixed(2);
    debt.balance = +(debt.balance - settle).toFixed(2);
    if (cred.balance <= 0.001) i++;
    if (debt.balance <= 0.001) j++;
  }
  return payments;
}

/* ================================
   Render Balances Sidebar
   ================================ */
function renderBalances(){
  balancesList.innerHTML = '';
  if (!groupMembers || groupMembers.length === 0) {
    balancesList.innerHTML = `<div class="text-xs text-slate-400">No approved members yet</div>`;
    return;
  }

  const entries = computeNetBalances();
  // prefer ordering by absolute value descending
  const ordered = entries.sort((a,b)=>Math.abs(b.balance) - Math.abs(a.balance));

  ordered.forEach(e => {
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between p-2 rounded hover:bg-slate-900 cursor-pointer border border-transparent hover:border-slate-800';
    row.innerHTML = `<div class="flex items-center gap-3">
        <div class="w-9 h-9 rounded-full bg-gradient-to-br from-slate-700 to-slate-800 flex items-center justify-center text-xs">${(e.name||'U').slice(0,2).toUpperCase()}</div>
        <div>
          <div class="text-sm font-medium">${e.name}</div>
          <div class="text-xs text-slate-400">${e.uid}</div>
        </div>
      </div>
      <div class="text-right">
        <div class="${e.balance >= 0 ? 'text-emerald-400 font-semibold' : 'text-rose-400 font-semibold'}">${formatMoney(e.balance)}</div>
      </div>`;
    balancesList.appendChild(row);

    row.onclick = () => {
      const balancesAll = computeNetBalances();
      const payments = simplifyDebts(balancesAll);
      // filter payments where this person is involved
      const related = payments.filter(p => p.fromUid === e.uid || p.toUid === e.uid);
      const body = document.getElementById('debtModalBody');
      const title = document.getElementById('debtModalTitle');
      title.innerText = `${e.name} — Balance ${formatMoney(e.balance)}`;
      if (related.length === 0) {
        body.innerHTML = `<div class="text-slate-400">No payments required for this member.</div>`;
      } else {
        body.innerHTML = related.map(p => {
          if (p.toUid === e.uid) {
            return `<div><span class="text-emerald-300">${p.fromName}</span> owes <b>${formatMoney(p.amount)}</b> to <span class="text-emerald-300">${p.toName}</span></div>`;
          } else {
            return `<div><span class="text-rose-300">${p.fromName}</span> pays <b>${formatMoney(p.amount)}</b> to <span class="text-rose-300">${p.toName}</span></div>`;
          }
        }).join('');
      }
      document.getElementById('debtModal').classList.remove('hidden');
      document.getElementById('debtModal').classList.add('flex');
    };
  });
}

/* ================================
   CSV Export
   ================================ */
exportCSV.onclick = async () => {
  // get all processed transactions
  const snap = await txCol.where('status','==','processed').get();
  const rows = [];
  snap.forEach(doc => {
    const d = doc.data();
    const parsed = d.parsed || {};
    const recips = (parsed.split_recipients || []).map(r => `${r.name}:${r.owed}`).join('|');
    rows.push([
      doc.id,
      d.fromEmail || '',
      parsed.payer || '',
      parsed.total_amount || '',
      `"${parsed.description || ''}"`,
      `"${recips}"`,
      d.processedAt ? new Date(d.processedAt.seconds*1000).toISOString() : ''
    ].join(','));
  });
  const header = ['id,fromEmail,payer,total_amount,description,split_recipients,processedAt'].join(',');
  const csv = [header, ...rows].join('\n');
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'processed_transactions.csv';
  a.click();
  URL.revokeObjectURL(url);
};

/* ================================
   Input UI events
   ================================ */
sendBtn.onclick = async () => {
  await handleSend();
};
nlInput.addEventListener('keydown', async (e) => {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
    await handleSend();
  }
});

async function handleSend() {
  if (!auth.currentUser) return alert('Sign in first.');
  if (!currentUser || currentUser.status !== 'approved') {
    return alert('Your account is not approved yet.');
  }
  const rawText = nlInput.value.trim();
  if (!rawText) return;
  // create a pending tx
  const txId = await createTransactionRaw(rawText);
  nlInput.value = '';
  // start parsing (async but we update doc so listeners update view)
  parseWithAI(rawText, txId);
}

/* Quick Split: a helpful utility to open quick input template */
document.getElementById('quickSplitBtn').onclick = () => {
  nlInput.value = 'Paid 1200 for groceries, split with all';
  nlInput.focus();
};

/* Debt modal close */
document.getElementById('closeDebtModal').onclick = () => {
  document.getElementById('debtModal').classList.add('hidden');
  document.getElementById('debtModal').classList.remove('flex');
};
document.getElementById('signOutPending').onclick = () => auth.signOut();

/* ================================
   Auth state observer
   ================================ */
auth.onAuthStateChanged(async user => {
  if (!user) {
    currentUser = null;
    renderAuthUI();
    // hide pending modal if visible
    pendingModal.classList.add('hidden');
    adminPanel.classList.add('hidden');
    userInfo.innerHTML = '';
    return;
  }

  // Load user document
  const doc = await usersCol.doc(user.uid).get();
  if (!doc.exists) {
    // fallback create user doc as pending
    const email = user.email || '';
    const role = (email.toLowerCase() === 'admin@expense.com') ? 'admin' : 'member';
    const status = (email.toLowerCase() === 'admin@expense.com') ? 'approved' : 'pending';
    await usersCol.doc(user.uid).set({email, name: email.split('@')[0], role, status, createdAt: firebase.firestore.FieldValue.serverTimestamp()});
    currentUser = {uid: user.uid, email, name: email.split('@')[0], role, status};
  } else {
    currentUser = {uid: user.uid, ...(doc.data())};
  }

  // Update UI
  renderAuthUI();

  // if status is pending -> show blocking modal
  if (currentUser.status !== 'approved') {
    pendingModal.classList.remove('hidden');
    pendingModal.classList.add('flex');
    // disable input
    sendBtn.disabled = true;
    nlInput.disabled = true;
  } else {
    pendingModal.classList.add('hidden');
    sendBtn.disabled = false;
    nlInput.disabled = false;
  }

  // admin panel visibility
  if (currentUser.role === 'admin') {
    adminPanel.classList.remove('hidden');
  } else {
    adminPanel.classList.add('hidden');
  }

  // Show current user info
  userInfo.innerHTML = `<div><span class="font-medium">${currentUser.name || currentUser.email}</span> • <span class="text-slate-400">${currentUser.role}</span></div>
    <div class="text-xs text-slate-400">Signed in as ${currentUser.email}</div>`;

  // ensure if admin and approved it's in members
  if (currentUser.role === 'admin' && currentUser.status === 'approved') {
    await membersCol.doc(currentUser.uid).set({uid: currentUser.uid, email: currentUser.email, name: currentUser.name || currentUser.email.split('@')[0], joinedAt: firebase.firestore.FieldValue.serverTimestamp()});
  }
});

/* ================================
   Initial UI boot
   ================================ */
renderAuthUI();
renderBalances();
renderTransactions();

</script>

</body>
</html>
